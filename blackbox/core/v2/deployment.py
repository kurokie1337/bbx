# Copyright 2025 Ilya Makarov
#
# Licensed under the Business Source License 1.1
# Change Date: 2028-11-05
# Change License: Apache License 2.0

"""
BBX 2.0 Deployment - Docker, Helm, and Kubernetes Operator support.

Features:
- Docker image generation
- Helm chart templates
- Kubernetes CRD and Operator
- Auto-scaling configuration
- Health checks
"""

from __future__ import annotations

import json
import logging
import os
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger("bbx.deployment")


class DeploymentTarget(Enum):
    DOCKER = "docker"
    KUBERNETES = "kubernetes"
    COMPOSE = "compose"


@dataclass
class ResourceRequirements:
    """Resource requirements for deployment"""
    cpu_request: str = "100m"
    cpu_limit: str = "1000m"
    memory_request: str = "256Mi"
    memory_limit: str = "2Gi"
    gpu_count: int = 0


@dataclass
class HealthCheck:
    """Health check configuration"""
    path: str = "/health"
    port: int = 8080
    initial_delay_seconds: int = 10
    period_seconds: int = 30
    timeout_seconds: int = 5
    failure_threshold: int = 3


@dataclass
class AutoscalingConfig:
    """Autoscaling configuration"""
    min_replicas: int = 1
    max_replicas: int = 10
    target_cpu_percent: int = 70
    target_memory_percent: int = 80
    scale_down_delay_seconds: int = 300


@dataclass
class AgentDeploymentSpec:
    """Specification for agent deployment"""
    name: str
    image: str
    replicas: int = 1
    resources: ResourceRequirements = field(default_factory=ResourceRequirements)
    health_check: HealthCheck = field(default_factory=HealthCheck)
    autoscaling: Optional[AutoscalingConfig] = None
    env_vars: Dict[str, str] = field(default_factory=dict)
    secrets: List[str] = field(default_factory=list)
    volumes: Dict[str, str] = field(default_factory=dict)
    labels: Dict[str, str] = field(default_factory=dict)
    annotations: Dict[str, str] = field(default_factory=dict)


class DockerfileGenerator:
    """Generates Dockerfiles for BBX agents"""

    def __init__(self, base_image: str = "python:3.11-slim"):
        self._base_image = base_image

    def generate(
        self,
        agent_name: str,
        requirements: Optional[List[str]] = None,
        entrypoint: str = "python -m bbx.agent"
    ) -> str:
        """Generate Dockerfile content"""
        requirements = requirements or ["bbx>=2.0.0"]

        dockerfile = f"""# BBX Agent: {agent_name}
# Auto-generated by BBX Deployment

FROM {self._base_image}

# System dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -u 1000 bbx
WORKDIR /app

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Set ownership
RUN chown -R bbx:bbx /app
USER bbx

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
    CMD curl -f http://localhost:8080/health || exit 1

# Environment
ENV BBX_AGENT_NAME={agent_name}
ENV PYTHONUNBUFFERED=1

EXPOSE 8080

ENTRYPOINT ["{entrypoint}"]
"""
        return dockerfile

    def generate_requirements(self, extra_deps: Optional[List[str]] = None) -> str:
        """Generate requirements.txt"""
        deps = [
            "bbx>=2.0.0",
            "fastapi>=0.100.0",
            "uvicorn>=0.23.0",
            "pydantic>=2.0.0",
            "httpx>=0.24.0",
            "redis>=4.6.0",
            "prometheus-client>=0.17.0"
        ]
        if extra_deps:
            deps.extend(extra_deps)
        return "\n".join(deps)


class HelmChartGenerator:
    """Generates Helm charts for BBX deployments"""

    def __init__(self, chart_name: str = "bbx-agent"):
        self._chart_name = chart_name

    def generate_chart(self, spec: AgentDeploymentSpec) -> Dict[str, str]:
        """Generate Helm chart files"""
        files = {}

        # Chart.yaml
        files["Chart.yaml"] = f"""apiVersion: v2
name: {self._chart_name}
description: BBX Agent Helm Chart
type: application
version: 1.0.0
appVersion: "2.0.0"
"""

        # values.yaml
        files["values.yaml"] = f"""replicaCount: {spec.replicas}

image:
  repository: {spec.image.split(':')[0] if ':' in spec.image else spec.image}
  tag: {spec.image.split(':')[1] if ':' in spec.image else 'latest'}
  pullPolicy: IfNotPresent

nameOverride: ""
fullnameOverride: ""

service:
  type: ClusterIP
  port: 8080

resources:
  requests:
    cpu: {spec.resources.cpu_request}
    memory: {spec.resources.memory_request}
  limits:
    cpu: {spec.resources.cpu_limit}
    memory: {spec.resources.memory_limit}

autoscaling:
  enabled: {str(spec.autoscaling is not None).lower()}
  minReplicas: {spec.autoscaling.min_replicas if spec.autoscaling else 1}
  maxReplicas: {spec.autoscaling.max_replicas if spec.autoscaling else 10}
  targetCPUUtilizationPercentage: {spec.autoscaling.target_cpu_percent if spec.autoscaling else 70}

env: {json.dumps(spec.env_vars)}

healthCheck:
  path: {spec.health_check.path}
  port: {spec.health_check.port}
"""

        # templates/deployment.yaml
        files["templates/deployment.yaml"] = """apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "bbx-agent.fullname" . }}
  labels:
    {{- include "bbx-agent.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "bbx-agent.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "bbx-agent.selectorLabels" . | nindent 8 }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.port }}
          livenessProbe:
            httpGet:
              path: {{ .Values.healthCheck.path }}
              port: {{ .Values.healthCheck.port }}
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: {{ .Values.healthCheck.path }}
              port: {{ .Values.healthCheck.port }}
            initialDelaySeconds: 5
            periodSeconds: 10
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          env:
            {{- range $key, $value := .Values.env }}
            - name: {{ $key }}
              value: {{ $value | quote }}
            {{- end }}
"""

        # templates/service.yaml
        files["templates/service.yaml"] = """apiVersion: v1
kind: Service
metadata:
  name: {{ include "bbx-agent.fullname" . }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.port }}
      protocol: TCP
  selector:
    {{- include "bbx-agent.selectorLabels" . | nindent 4 }}
"""

        # templates/_helpers.tpl
        files["templates/_helpers.tpl"] = """{{- define "bbx-agent.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{- define "bbx-agent.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}

{{- define "bbx-agent.labels" -}}
helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
app.kubernetes.io/name: {{ include "bbx-agent.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{- define "bbx-agent.selectorLabels" -}}
app.kubernetes.io/name: {{ include "bbx-agent.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}
"""

        return files


class KubernetesOperator:
    """Generates Kubernetes Operator for BBX"""

    def generate_crd(self) -> str:
        """Generate Custom Resource Definition"""
        return """apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: bbxagents.bbx.io
spec:
  group: bbx.io
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                agentName:
                  type: string
                image:
                  type: string
                replicas:
                  type: integer
                  minimum: 1
                  maximum: 100
                resources:
                  type: object
                  properties:
                    cpu:
                      type: string
                    memory:
                      type: string
                autoscaling:
                  type: object
                  properties:
                    enabled:
                      type: boolean
                    minReplicas:
                      type: integer
                    maxReplicas:
                      type: integer
                env:
                  type: object
                  additionalProperties:
                    type: string
            status:
              type: object
              properties:
                phase:
                  type: string
                replicas:
                  type: integer
                readyReplicas:
                  type: integer
                conditions:
                  type: array
                  items:
                    type: object
      subresources:
        status: {}
  scope: Namespaced
  names:
    plural: bbxagents
    singular: bbxagent
    kind: BBXAgent
    shortNames:
      - bbxa
"""

    def generate_operator_deployment(self) -> str:
        """Generate operator deployment"""
        return """apiVersion: apps/v1
kind: Deployment
metadata:
  name: bbx-operator
  namespace: bbx-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: bbx-operator
  template:
    metadata:
      labels:
        app: bbx-operator
    spec:
      serviceAccountName: bbx-operator
      containers:
        - name: operator
          image: bbx/operator:latest
          ports:
            - containerPort: 8080
          env:
            - name: WATCH_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 512Mi
"""

    def generate_rbac(self) -> str:
        """Generate RBAC configuration"""
        return """apiVersion: v1
kind: ServiceAccount
metadata:
  name: bbx-operator
  namespace: bbx-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: bbx-operator
rules:
  - apiGroups: [""]
    resources: ["pods", "services", "configmaps", "secrets"]
    verbs: ["*"]
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets"]
    verbs: ["*"]
  - apiGroups: ["bbx.io"]
    resources: ["bbxagents", "bbxagents/status"]
    verbs: ["*"]
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: bbx-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: bbx-operator
subjects:
  - kind: ServiceAccount
    name: bbx-operator
    namespace: bbx-system
"""


@dataclass
class DeploymentConfig:
    """Deployment configuration"""
    target: DeploymentTarget = DeploymentTarget.KUBERNETES
    namespace: str = "default"
    registry: str = "docker.io"
    image_prefix: str = "bbx"


class DeploymentManager:
    """
    Production deployment manager.

    Features:
    - Docker image building
    - Helm chart generation
    - Kubernetes deployment
    - Health monitoring
    """

    def __init__(self, config: Optional[DeploymentConfig] = None):
        self.config = config or DeploymentConfig()
        self._dockerfile_gen = DockerfileGenerator()
        self._helm_gen = HelmChartGenerator()
        self._k8s_operator = KubernetesOperator()

    def generate_dockerfile(
        self,
        agent_name: str,
        extra_deps: Optional[List[str]] = None
    ) -> Dict[str, str]:
        """Generate Dockerfile and requirements"""
        return {
            "Dockerfile": self._dockerfile_gen.generate(agent_name),
            "requirements.txt": self._dockerfile_gen.generate_requirements(extra_deps)
        }

    def generate_helm_chart(self, spec: AgentDeploymentSpec) -> Dict[str, str]:
        """Generate Helm chart"""
        return self._helm_gen.generate_chart(spec)

    def generate_k8s_manifests(self, spec: AgentDeploymentSpec) -> Dict[str, str]:
        """Generate Kubernetes manifests"""
        manifests = {}

        # CRD
        manifests["crd.yaml"] = self._k8s_operator.generate_crd()

        # Operator
        manifests["operator.yaml"] = self._k8s_operator.generate_operator_deployment()

        # RBAC
        manifests["rbac.yaml"] = self._k8s_operator.generate_rbac()

        # Agent CR
        manifests[f"{spec.name}.yaml"] = f"""apiVersion: bbx.io/v1
kind: BBXAgent
metadata:
  name: {spec.name}
  namespace: {self.config.namespace}
spec:
  agentName: {spec.name}
  image: {spec.image}
  replicas: {spec.replicas}
  resources:
    cpu: {spec.resources.cpu_limit}
    memory: {spec.resources.memory_limit}
  autoscaling:
    enabled: {str(spec.autoscaling is not None).lower()}
    minReplicas: {spec.autoscaling.min_replicas if spec.autoscaling else 1}
    maxReplicas: {spec.autoscaling.max_replicas if spec.autoscaling else 10}
  env: {json.dumps(spec.env_vars)}
"""

        return manifests

    def build_docker_image(
        self,
        context_path: str,
        image_name: str,
        tag: str = "latest"
    ) -> bool:
        """Build Docker image"""
        full_image = f"{self.config.registry}/{self.config.image_prefix}/{image_name}:{tag}"

        try:
            subprocess.run(
                ["docker", "build", "-t", full_image, context_path],
                check=True,
                capture_output=True
            )
            logger.info(f"Built image: {full_image}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"Docker build failed: {e.stderr.decode()}")
            return False
        except FileNotFoundError:
            logger.error("Docker not found")
            return False

    def push_docker_image(self, image_name: str, tag: str = "latest") -> bool:
        """Push Docker image to registry"""
        full_image = f"{self.config.registry}/{self.config.image_prefix}/{image_name}:{tag}"

        try:
            subprocess.run(
                ["docker", "push", full_image],
                check=True,
                capture_output=True
            )
            logger.info(f"Pushed image: {full_image}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"Docker push failed: {e.stderr.decode()}")
            return False
        except FileNotFoundError:
            logger.error("Docker not found")
            return False

    def deploy_helm(
        self,
        chart_path: str,
        release_name: str,
        values_override: Optional[Dict[str, Any]] = None
    ) -> bool:
        """Deploy Helm chart"""
        cmd = [
            "helm", "upgrade", "--install",
            release_name, chart_path,
            "--namespace", self.config.namespace,
            "--create-namespace"
        ]

        if values_override:
            for key, value in values_override.items():
                cmd.extend(["--set", f"{key}={value}"])

        try:
            subprocess.run(cmd, check=True, capture_output=True)
            logger.info(f"Deployed Helm release: {release_name}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"Helm deploy failed: {e.stderr.decode()}")
            return False
        except FileNotFoundError:
            logger.error("Helm not found")
            return False

    def apply_k8s_manifests(self, manifests: Dict[str, str]) -> bool:
        """Apply Kubernetes manifests"""
        with tempfile.TemporaryDirectory() as tmpdir:
            for name, content in manifests.items():
                path = Path(tmpdir) / name
                path.write_text(content)

            try:
                subprocess.run(
                    ["kubectl", "apply", "-f", tmpdir],
                    check=True,
                    capture_output=True
                )
                logger.info("Applied Kubernetes manifests")
                return True
            except subprocess.CalledProcessError as e:
                logger.error(f"kubectl apply failed: {e.stderr.decode()}")
                return False
            except FileNotFoundError:
                logger.error("kubectl not found")
                return False


# Factory
_global_deployment: Optional[DeploymentManager] = None


def get_deployment_manager() -> DeploymentManager:
    global _global_deployment
    if _global_deployment is None:
        _global_deployment = DeploymentManager()
    return _global_deployment


def create_deployment_manager(config: Optional[DeploymentConfig] = None) -> DeploymentManager:
    return DeploymentManager(config)
