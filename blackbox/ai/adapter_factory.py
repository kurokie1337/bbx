# Copyright 2025 Ilya Makarov
#
# Licensed under the Business Source License 1.1
# Change Date: 2028-11-05
# Change License: Apache License 2.0

"""
AIAdapterFactory: Just-in-Time Driver Generation

This module implements the "Self-Building OS" concept where BBX learns
new tools dynamically by reading documentation and generating adapters.
"""

import subprocess
import re
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from pathlib import Path
import json


@dataclass
class ToolSignature:
    """Extracted signature of a CLI tool"""
    name: str
    description: str
    commands: List[Dict[str, str]]  # [{cmd: "deploy", description: "..."}]
    options: List[Dict[str, Any]]   # [{flag: "--region", type: "string"}]
    examples: List[str]


class DocumentationParser:
    """Parses CLI tool documentation to extract structured information"""

    def parse_help_output(self, help_text: str, tool_name: str) -> ToolSignature:
        """Parse --help output into structured data"""

        lines = help_text.split("\n")
        description = ""
        commands = []
        options = []
        examples = []

        current_section = None

        for line in lines:
            line = line.strip()

            # Detect sections
            if line.lower().startswith("usage:"):
                current_section = "usage"
            elif line.lower().startswith("commands:") or line.lower().startswith("available commands:"):
                current_section = "commands"
            elif line.lower().startswith("options:") or line.lower().startswith("flags:"):
                current_section = "options"
            elif line.lower().startswith("examples:"):
                current_section = "examples"

            # Extract based on section
            if current_section == "commands" and line and not line.lower().startswith("commands"):
                # Pattern: "  deploy     Deploy application"
                match = re.match(r"^\s*([a-z\-]+)\s+(.+)$", line)
                if match:
                    commands.append({
                        "cmd": match.group(1),
                        "description": match.group(2).strip()
                    })

            elif current_section == "options" and line and line.startswith("-"):
                # Pattern: "  --region <string>  AWS region"
                match = re.match(r"^\s*(--?[\w\-]+)\s+(?:<(\w+)>)?\s*(.*)$", line)
                if match:
                    options.append({
                        "flag": match.group(1),
                        "type": match.group(2) or "string",
                        "description": match.group(3).strip()
                    })

            elif current_section == "examples" and line and ("$" in line or tool_name in line):
                examples.append(line)

        return ToolSignature(
            name=tool_name,
            description=description or f"{tool_name} CLI tool",
            commands=commands,
            options=options,
            examples=examples
        )

    def parse_man_page(self, man_text: str, tool_name: str) -> ToolSignature:
        """Parse man page output (future enhancement)"""
        # For MVP, delegate to help parser
        return self.parse_help_output(man_text, tool_name)


class AdapterGenerator:
    """Generates BBX adapter YAML from tool signatures"""

    def generate_adapter_yaml(self, signature: ToolSignature) -> str:
        """Generate BBX v6.0 compatible adapter YAML"""

        yaml_lines = [
            f"# Auto-generated adapter for {signature.name}",
            "# Generated by BBX AIAdapterFactory",
            "",
            "adapter:",
            f"  name: \"{signature.name}\"",
            f"  id: \"bbx.learned.{signature.name}\"",
            "  version: \"1.0.0-auto\"",
            f"  description: \"{signature.description}\"",
            "  category: \"Auto-Generated\"",
            "",
            "  methods:"
        ]

        # Generate method for each command
        for cmd in signature.commands:
            cmd_name = cmd["cmd"].replace("-", "_")
            yaml_lines.extend([
                f"    - id: {cmd_name}",
                f"      description: \"{cmd['description']}\"",
                "      inputs:",
            ])

            # Add inputs based on discovered options
            for opt in signature.options:
                opt_name = opt["flag"].lstrip("-").replace("-", "_")
                yaml_lines.append(f"        {opt_name}: {opt['type']}")

            yaml_lines.extend([
                "      implementation:",
                "        type: shell",
                f"        command: \"{signature.name} {cmd['cmd']} {{{{args}}}}\"",
                ""
            ])

        return "\n".join(yaml_lines)

    def generate_adapter_python(self, signature: ToolSignature) -> str:
        """Generate Python adapter class (alternative to YAML)"""

        methods = []
        for cmd in signature.commands:
            cmd_name = cmd["cmd"].replace("-", "_")
            methods.append(f"""
    def {cmd_name}(self, **kwargs):
        \"\"\" {cmd['description']} \"\"\"
        args = self._build_args(kwargs)
        return self._execute("{signature.name} {cmd['cmd']}", args)
""")

        python_code = f"""
# Auto-generated adapter for {signature.name}
from blackbox.core.base_adapter import BaseAdapter

class {signature.name.capitalize()}Adapter(BaseAdapter):
    \"\"\" {signature.description} \"\"\"

    def __init__(self):
        super().__init__("{signature.name}")

    def _build_args(self, kwargs):
        args = []
        for key, value in kwargs.items():
            flag = "--" + key.replace("_", "-")
            args.extend([flag, str(value)])
        return " ".join(args)

    def _execute(self, base_cmd, args):
        import subprocess
        full_cmd = f"{{base_cmd}} {{args}}"
        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
        return {{
            "exit_code": result.returncode,
            "stdout": result.stdout,
            "stderr": result.stderr
        }}

{"".join(methods)}
"""
        return python_code


class AIAdapterFactory:
    """
    The core "Learning Engine" that reads documentation and generates adapters.

    Usage:
        factory = AIAdapterFactory()
        adapter = factory.learn("kubectl")
        # BBX can now use kubectl commands!
    """

    def __init__(self, cache_dir: Optional[Path] = None):
        self.parser = DocumentationParser()
        self.generator = AdapterGenerator()
        self.cache_dir = cache_dir or Path.home() / ".bbx" / "learned_adapters"
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def introspect_tool(self, tool_name: str) -> Optional[ToolSignature]:
        """
        Run the tool with --help and parse its output.
        """
        print(f"[AIAdapterFactory] Introspecting {tool_name}...")

        try:
            # Try common help flags
            for help_flag in ["--help", "-h", "help"]:
                try:
                    result = subprocess.run(
                        [tool_name, help_flag],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )

                    if result.returncode == 0 or result.stdout:
                        help_text = result.stdout or result.stderr
                        signature = self.parser.parse_help_output(help_text, tool_name)

                        if signature.commands or signature.options:
                            print(f"[AIAdapterFactory] Discovered {len(signature.commands)} commands")
                            return signature
                except FileNotFoundError:
                    print(f"[AIAdapterFactory] Tool {tool_name} not found in PATH")
                    return None
                except Exception:
                    continue

        except Exception as e:
            print(f"[AIAdapterFactory] Error introspecting {tool_name}: {e}")

        return None

    def verify_adapter(self, tool_name: str, signature: ToolSignature) -> bool:
        """
        Run a simple test command to verify the generated adapter would work.
        """
        print(f"[AIAdapterFactory] Verifying {tool_name} adapter...")

        # Try to run the tool with --version (safe test)
        try:
            subprocess.run(
                [tool_name, "--version"],
                capture_output=True,
                text=True,
                timeout=5,
                check=False  # Don't raise on non-zero exit
            )
            print("[AIAdapterFactory] ‚úì Tool is executable")
            return True
        except Exception as e:
            print(f"[AIAdapterFactory] ‚úó Verification failed: {e}")
            return False

    def learn(self, tool_name: str, output_format: str = "yaml") -> Optional[str]:
        """
        The main "learning" function.

        Steps:
        1. Introspect the tool (run --help)
        2. Parse documentation
        3. Generate adapter code
        4. Verify it works
        5. Save to cache

        Returns:
            Path to generated adapter file, or None if learning failed
        """
        print(f"\nüß† BBX is learning: {tool_name}")
        print("=" * 60)

        # Step 1: Introspect
        signature = self.introspect_tool(tool_name)
        if not signature:
            print(f"‚ùå Failed to introspect {tool_name}")
            return None

        # Step 2: Generate adapter
        if output_format == "yaml":
            adapter_code = self.generator.generate_adapter_yaml(signature)
            extension = "yaml"
        else:
            adapter_code = self.generator.generate_adapter_python(signature)
            extension = "py"

        # Step 3: Verify (optional but recommended)
        if not self.verify_adapter(tool_name, signature):
            print("‚ö†Ô∏è  Warning: Adapter verification failed, but continuing...")

        # Step 4: Save to cache
        output_path = self.cache_dir / f"{tool_name}_adapter.{extension}"
        output_path.write_text(adapter_code)

        print(f"\n‚úÖ Adapter generated: {output_path}")
        print("üìä Capabilities:")
        print(f"   ‚Ä¢ {len(signature.commands)} commands")
        print(f"   ‚Ä¢ {len(signature.options)} options")

        # Step 5: Return metadata
        metadata = {
            "tool": tool_name,
            "adapter_path": str(output_path),
            "format": output_format,
            "commands": [cmd["cmd"] for cmd in signature.commands],
            "generated_at": "2025-11-24"
        }

        metadata_path = self.cache_dir / f"{tool_name}_metadata.json"
        metadata_path.write_text(json.dumps(metadata, indent=2))

        return str(output_path)

    def list_learned_tools(self) -> List[str]:
        """List all tools that BBX has learned"""
        adapters = list(self.cache_dir.glob("*_adapter.*"))
        return [a.stem.replace("_adapter", "") for a in adapters]


# CLI Interface for testing
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python adapter_factory.py <tool_name>")
        print("Example: python adapter_factory.py kubectl")
        sys.exit(1)

    tool = sys.argv[1]
    factory = AIAdapterFactory()
    result = factory.learn(tool)

    if result:
        print(f"\nüéâ Success! BBX has learned {tool}")
        print(f"üìÅ Adapter saved to: {result}")
    else:
        print(f"\n‚ùå Failed to learn {tool}")
        sys.exit(1)
